# 第1节 代码优化

Web前端性能优化WPO，相信大多数前端同学都不会陌生，在各自所负责的站点页面中，也都会或多或少的有过一定的技术实践。可以说，这个领域并不缺乏成熟技术理论和技术牛人：例如Yahoo的web站点性能优化黄金法则，以及大名鼎鼎的优化大师Steve Souders。

网络上有大量的的前端性能优化文章，这里我综合各种文章总结如下：

1. 代码优化
2. Web图像优化
3. 使用缓存

其实各种CSS、HTML、JavaScript最佳实践就可以看成一种优化方案。下面主要讲一下JavaScript最佳实践。

## 一、注意作用域

随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加，访问全局变量总是比访问局部变量慢，只要能减少花费在作用域链上的时间，就能增加脚本的整体性能。

### **1.1 避免全局查找**

可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销大，因为要设计作用域链上的查找。

### **1.2 避免with语句**

在性能非常重要的地方必须避免使用with语句。和函数类似，with语句会创建自己的作用域，因此会增加其中执行代码的作用域链的长度。由于额外的作用域链查找，在with 语句中执行的代码肯定会比外面执行的代码要慢。

## 二、选择正确的方法

和其他语言一样，性能问题的一部分是和用于解决问题的算法或者方法有关系的。老练的开发者根据经验可以得知哪种方法能获得更好的性能。

### **2.1 避免不必要的属性查找**

在计算机科学当中，算法的复杂度是使用 O 符号来表示的。最简单、最快捷的算法是常数值即O\(1\)。之后，算法变的越来越复杂并花费更长的时间执行。下面的表格列出了JavaScript中常见的算法类型。

| 标记 | 名称 | 描述 |
| :--- | :--- | :--- |
| O\(1\) | 常数 | 不管有多少值，执行的时间都是恒定的，一般表示简单值和储存在变量中的值 |
| O\(log n\) | 对数 | 总的执行时间和值的数量相关，但是要完成算法并不一定要获取每个值，例如：二分查找 |
| O\(n\) | 线性 | 总的执行时间和值的数量直接相关，例如：遍历某个数组中的所有元素 |
| O\(n[^2]\) | 平方 | 总的执行时间和值的数量有关，每个值至少要获取 n 次，例如：插入排序 |

获取常量值是非常高效的过程，如下代码：

```js
var value = 5；
var sum = 10 + value;
alert(sum);
```

这段代码额整体复杂度被认为是O\(1\)。

在JavaScript中访问数组元素也是一个O\(1\)操作，和简单的变量查找效率一样。所以下面的代码和前面额代码效率一样：

```js
var values = [5, 10];
var sum = values[0] + values[1];
alert(sum);
```

使用变量和数组要比访问对象上的属性更有效率，后者是一个O\(n\)操作。**对象上的任何属性查找都要比访问变量或者数组话费更长时间，因为必须在原型链中对象拥有改名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。**

注意获取单个值的多重属性查找，例如：

```js
var query = window.location.href.substring(window.location.href.indexof('?'));
```

这段代码中，有6次属性查找：window.location.href.substring\(\)有3次，window.location.href.substring.href.indexOf\(\)又有3次。这段代码由于两次用到了window.location.href ，同样的查找进行了两次，因此效率特别不好。

优化如下：

```js
var url = window.location.href;
var query = url.substring(url.indexOf('?'));
```

这个版本的代码只有4次属性查找。

一般来讲，只要能较少算法的复杂度就要尽可能的减少。

### **2.2 优化循环**

一个循环 基本优化步骤如下：

* 减值迭代。大多数循环使用一个从0开始、增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效。
* 简化终止条件。由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说避免属性查找或其他O\(n\)的操作。
* 简化循环体。循环体是执行最多的，所以要确保其被最大限度的优化。确保没有任何可以被很容易移除循环额密集计算。
* 使用后测试循环。最常用额 for 循环和 while 循环都是前测试循环。而如 do-while 这种后测试循环可以避免最初终止条件额计算，因此运行更快。

### **2.3 展开循环**

当循环的次数是确定的，消除循环并使用多次函数调用往往更快。请看如下例子

```js
// 消除循环
process(values[0]);
process(values[1]);
process(values[2]);
```

如果数组的长度总是一致的，对每个元素都调用 process\(\) 可能更优。

### **2.4 避免双重解析**

当JavaScript代码解析JavaScript的时候就会存在双重解析惩罚。当使用 eval\(\) 函数或者 function 构造函数以及使用 setTimeout\(\) 传一个字符串参数的时候都会发生这种情况。

```js
// 某些代码求值——避免！
eval("alert('hello world')");

// 创建新函数——避免！ 
var sayHi = new Function("alert('hello world'));

// 设置超时——避免！
setTimeout("alert('hello world')", 1000);
```

下面并非主要问题，不过如果使用得当也会有相当大的提升：

* 原生方法较快。只要有可能，使用原生方法而不是自己用JavaScript重写一个。原生方法使用诸如 C/C++ 之类额编译性语言写出来的，所以比JavaScript的快很多。
* switch 语句较快。如果有一系列额 if-else 语句。可以转化为单个 switch 语句则可以得到更快的代码。还可以通过将 case 语句顺序按照最可能的到最不可能的顺序进行组织来进一步优化 switch 语句。
* 位运算符较快。当进行数学运算的时候，位运算操作要比任何布尔运算或者算术运算快。

## 三、最少化语句数

JavaScript代码中的语句数量也影响所执行的操作的速度。完成多个操作的单个语句要比完成单个操作的多个语句快。所以，就要找出可以组合在一起的语句，以减少脚本整体的执行时间。这里有几个可以参考的模式。

### **3.1 多个变量声明**

如下代码

```js
// 4个语句——很浪费！
var count = 5;
var color = "red";
var values = [1, 2, 3];
var now = new Date();
```

优化如下

```
// 一个语句
var count = 5,
    color = "red",
    values = [1, 2, 3],
    now = new Date();
```

### **3.2 插入迭代值**

如下代码

```js
var name = values[i];
i++;
```

优化如下

```js
var name = values[i++];
```

### **3.3 使用数组和对象字面量**

## 四、优化DOM交互

在JavaScript各个方面中，DOM毫无疑问是最慢的一部分。DOM操作与交互要消耗大量时间，因为它们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能要花很久来执行，因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大得提高脚本完成的速度。

### 4.1 最少化现场更新

一旦你需要访问的DOM部分是已经显示的页面的一部分，那么你就是在进行一个现场更新。之所以叫现场更新，是因为需要立即（现场）对页面对用户的显示进行更新。每一个更改，不管是插入单个字符，还是移除整个片段，都有一个性能惩罚，因为浏览器要重新计算无数尺寸以进行更新。

现场更新进行得越多，代码完成执行所花的时间就越长；完成一个操作所需的现场更新越少，代码就越快。请看以下例子：

```js
var list = document.getElementById("myList"),
    item,
    i;
for(i = 0; i < 10; i++) {
    item = document.createElement("li");
    list.appendChild(item);
    item.appendChild(document.createTextNode("Item " + i));
}
```

这段代码为列表添加了10个项目。添加每个项目时，都有2个现场更新：一个添加&lt;li&gt;元素，另一个给它添加文本节点。这样添加10个项目，这个操作总共要完成20个现场更新。

要修正这个性能瓶颈，需要减少现场更新的数量。一般有2种方法。

* 第一种是将列表从页面上移除，最后进行更新，最后再将列表插回到同样的位置。这个方法不是非常理想，因为在每次页面更新的时候它会不必要的闪烁。
* 第二个方法是使用文档碎片来构建DOM结构，接着将其添加到 List 元素中。

### 4.2 使用 innerHTML

有两种在页面上创建DOM节点的方法：

* 使用诸如createElement\(\)和appendChild\(\)之类的DOM方法
* 以及使用innerHTML。

对于小的DOM更改而言，两种方法效率都差不多。然而，对于大的DOM更改，使用innerHTML要比使用标准DOM方法创建同样的DOM结构快得多。

### 4.3 使用事件代理

大多数Web应用在用户交互上大量用到事件处理程序。页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。为了减轻这种惩罚，最好使用事件代理。

**任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理。**使用这个知识，就可以将事件处理程序附加到更高层的地方负责多个目标的事件处理。如果可能，在文档级别附加事件处理程序，这样可以处理整个页面的事件。

### 4.4 注意 HTMLCollection

对于Web应用的性能而言是巨大的损害。**记住，任何时候要访问HTMLCollection，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。**

也许优化HTMLCollection访问最重要的地方就是循环了。前面提到过将长度计算移入for循环的初始化部分。现在看一下这个例子：

```js
var images = document.getElementsByTagName("img"),
    i,
    leng;
for (i = 0, len = images.length; i < len; i++) {
    // 处理
}
```

这里的关键在于长度length存入了len变量，而不是每次都去访问HTMLCollection的length属性。当在循环中使用HTMLCollection的时候，下一步应该是获取要使用的项目的引用，如下所示，以便避免在循环体内多次调用HTMLCollection。

```js
var images = document.getElementsByTagName("img"),
    image,
    i,
    leng;
for (i = 0, len = images.length; i < len; i++) {
    image = images[i];
    // 处理
}
```

这段代码添加了image变量，保存了当前的图像。这之后，在循环内就没有理由再访问images的HTMLCollection了。

编写JavaScript的时候，一定要知道何时返回HTMLCollection对象，这样你就可以最小化对他们的访问。发生以下情况时会返回HTMLCollection对象：

* 进行了对 getElementsByTagName\(\) 的调用；
* 获取了元素  childNodes 属性；
* 获取元素的 attributes 属性；
* 访问了特殊 集合，如 document.forms、document.images等

要了解当使用 HTMLCollection 对象时，合理使用会极大提升代码执行速度。

---

以上内容来自于《JavaScript高级程序设计（第三版）》第24章第2节：性能

