# 第11节 函数防抖与节流

## 一、函数节流

比较直白的说，函数节流就是强制规定一个函数在一段时间内能够被执行的最大次数，比如，规定某个函数在每100毫秒的时间段内，最多被执行一次,那么对应的在10s(10000ms)内，最多就会执行100(10000ms/100ms)次

在浏览器中，频繁的DOM操作非常消耗内存和CPU时间，比如监听了resize,touchmove,scroll...等事件，在dom改变时都会不断触发回调。现在的react 和 vue 等前端框架都提出了虚拟DOM的概念，会把多次DOM操作合并到一次真实操作中，就是使用了Diff算法，这样就大大减低了DOM操作的频次。但是，这里并不是要讨论diff算法，如果感兴趣可以戳上面的链接，而是解释如何利用setTimeout来减低DOM频繁操作的风险。

函数节流背后的基本思想是指，某些代码不可以在没有间断的情况下连续重复执行.第一次调用函数，创建了一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。

封装方法也比较简单：

```js
function throttle(method,context) {
    clearTimeout(method.tId);
    method.tId = setTimeout(function(){
       method.call(context)
    },1000)
}
```

使用定时器，让函数延迟1秒后执行，在此1秒内，然后throttle函数再次被调用，则删除上次的定时器，取消上次调用的队列任务，重新设置定时器。这样就可以保证1秒内函数只会被触发一次，达到了函数节流的目的

可以利用 resize事件测试一下:
```js
var  i = 0;
function handler(){
    console.log(i++);
 }
window.onresize = function(){
    throttle(handler,window)
}
```

可以发现，在浏览器的调试模式下，切换横屏/竖屏，只触发了一次

## 二、函数防抖

函数防抖 规定函数再次执行需要满足两个条件：

1. 必须要等待一段时间；
2. 在条件1等待的时间段内不再被触发，一旦在条件1等待的时间内再次被触发，等待时间就要重新开始计算。





