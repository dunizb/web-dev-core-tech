# 第1节 核心知识归纳

## 一、面向对象

面向对象就是使用对象。面向对象开发就是使用对象开发。

面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

### 三大特性

**抽象性**

所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

1. 提出需要的核心属性和方法
2. 不在特定的环境下无法明确对象的具体意义

**封装性**

对象是将数据与功能组合到一起，即封装

1. JS对象就是键值对的集合，键值如果是数据（基本数据、符合数据、空数据）就称为属性，如果键值是函数那么就称为方法
2. 对象就是将属性与方法封装起来
3. 方法是将过程封装起来

**继承性**

所谓继承性就是自己没有但是别人有，拿过来成为自己的，就是继承，继承是实现复用的一种手段

1. 在Java等语言中继承满足一个class的规则，类是一个class，他规定了一个对象有什么属性和方法。
2. 在这些语言中继承是class之间的继承，一个class继承另一个class，那么该class就有了另一个class的成员，那么由该class创建出来的对象就同时具有两个class的成员。

在JS中没有明确的继承语法（ES6提供了class extend语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此JS中实现继承的方法非常对多。

> 传统继承基于类，JS继承基于对象

一个简单的继承模式：混入（mix）

```js
function mix ( o1, o2 ) {
    for ( var k in o2 ) {
        o1[ k ] = o2[ k ];
    }
}
```

## 二、关于面向对象的一些其他概念

**类class：在JS中就是构造函数**

* 在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象。
* 在构造方法中也具有类似的功能，因此也称其为类

**实例（instance）与对象（object）**

* 实例一般是指某一个构造函数创建出来的对象，我们称为XXXX 构造函数的实例
* 实例就是对象。对象是一个泛称
* 实例与对象是一个近义词

**键值对与属性和方法**

* 在JS中键值对的集合称为对象
* 如果值为数据（非函数），就称该键值对为属性
* 如果值为函数（方法），就称该键值对为方法method

**父类与子类（基类和派生类）**

传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念

* 父类又称为基类，子类又称为派生类
* 在JS中没有类的概念，在JS中常常称为父对象，子对象，基对象，派生对象。

## 三、构造函数

构造函数是干什么用的？

1. 初始化数据的
2. 在JS中给对象添加属性用的，初始化属性值用的

创建对象的过程？

代码：var p = new Person\(\);

* 首先运算符new创建了一个对象，类似于{}，是一个没有任何（自定义）成员的对象。
  * 使用new 创建对象，那么对象的类型就是创建他的构造函数名
  * 使用{}无论如何都是Object类型，相当于new Object
* 然后调用构造函数，为其初始化成员
  * 构造函数在调用的一开始，有一个赋值操作，即this = 刚刚创建出来的对象。
  * 因此在构造函数中this表示刚刚创建出来的对象。
* 在构造函数中 利用 对象的动态特性 为其对象添加成员。

## 四、作用域

域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么时候不能使用。

JS中词法作用域的规则：

1. 函数允许访问函数外部的数据
2. 整个代码结构中只有函数可以限定作用域
3. 作用规则首先使用提升规则分析
4. 如果当前作用域中有了名字了，就不考虑外面的名字

属性搜索原则：

所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找

* 如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法
* 如果当前对象没有该成员，那么再在其原型对象中查找
* 如果原型对象中含有该成员，那么停止查找，直接使用
* 如果原型中还没有，就到原型的原型中查找

如此往复，直到Object.protitype还没有，那么就返回undefined。

如果是调用方法就报错，该xxx不是一个函数。

## 五、闭包

**什么是闭包？**

闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。

**为什么函数可以构成闭包？**

闭包就是一个具有封闭与包裹功能的结构，是为了实现具有私有访问空间的函数的。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。

**闭包有什么用？**

闭包不允许外部访问，要解决的问题就是让外部间接访问函数内部的数据。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：

* 匿名自执行函数。一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。
* 缓存。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。
* 实现封装。
* 模拟面向对象的代码风格

**闭包的基本模型**

* 对象模式。函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据。
* 函数模式。函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据。
* 沙箱模式。沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响。

**闭包的作用举例**

* 获得超过一个数据，返回一个对象
* 完成读取一个数据和修改这个数据，对象里面的get\set方法

**闭包的性能问题**

函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个null

```js
var f = (function () {
    var num = 123;
    return function () {
        return num;
    };
})();
// f 引用着函数，函数引用着变量num
// 因此在不使用该数据的时候，最好写上
f = null;
```

## 六、原型

一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。

JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object\(这就很类似Java中所有的类默认继承自Object类\)。

ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。

**查看对象的原型**

当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的\_\_proto\_\_属性，ES6推出后，推荐用Object.getPrototypeOf\(\)方法来获取对象的原型

```js
function A(){
    this.name='lala';
}
var a=new A();
console.log(a.__proto__) 
//输出：Object {}
 
//推荐使用这种方式获取对象的原型
console.log(Object.getPrototypeOf(a)) 
//输出：Object {}
```

无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是_proto_和prototype，而且两个属性并不相同





















