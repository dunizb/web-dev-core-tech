# 第四章 响应

## 一、概述

服务器执行了客户端请求后，需要给客户端以响应，告知它请求的执行状态、以及放置在消息主体内的执行结果。

响应消息构成：

```
状态行（响应首行）
首部字段
空行
响应主体（响应消息）
```

**状态行（ Status-Line\)**

由HTTP版本、状态码、状态说明共三个字段构成，中间用空格隔开

```
HTTP/1.1 200 OK
```

状态说明（Reason-Phrase）就是一个给人类阅读的内容，对于处理逻辑并不重要。 HTTP版本、状态码则直接影响客户端如何处理此响应消息。状态码是一个三位的数字，用来告知客户端请求的处理结果。三位数字的第一位是一个分类，指明状态码的类型，以此数字把状态码分为5类：

* 1xx: 信息类 。
* 2xx: 成功。请求被成功的接受或者理解，或者执行。我们常见的200 OK就是这个分类内的。
* 3xx: 重定向 - 为完成请求，需要进一步的行动。我们常见的301 Redirect就是这个分类内的。
* 4xx: 客户端错误。客户端提交的数据错误，不能被理解或者接受等等。我们常见的404 Not Found 就是这个分类内的。
* 5xx: 服务器错误。错误发生了，是服务器的问题，和客户端无关。

本书内，我们把响应消息按照状态码类别的不同分为6节来阐释。2xx-5xx 的各有一节。而其中1xx内的状态码目前只有两个，但是因为它们俩都相对比较复杂，因此拆分为两节，以便说明和理解。

**首部字段**

和请求消息的首部字段类似，只是因为请求和响应的差异，可以选择的首部字段各有不同。这些字段会在随后的章节，随同状态码分类来做介绍。

**消息主体 （message-body）**

消息主体承载响应请求消息的具体内容。会在随后的章节，随同状态码分类来做介绍。

## 二、响应码介绍

### 200 型响应

200 系列的状态码都可以表示请求已经成功处理。可是作为成功的语义，细节可以各不相同。并且对 HTTP 客户端有不同的动作指示，比如是否刷新当前页面内容等。

首先看下本类型响应下的具体状态码列表：

* 200 OK
* 201 Created
* 202 Accepted
* 204 No Content
* 205 Reset Content
* 206 Partial Content



**200 OK **

可能是最常用的状态。它指明请求已经成功完成。

**201 Created **

201 Created 会比200 OK 有更加具体的语义。201指明请求成功且创建了一个资源，因此201常常配合PUT方法使用，因为PUT方法的语义上就是创建一个资源。

**202 Accepted** 

202 Accepted 会比200 OK 有更加具体的语义。202表明请求成功被接受，但不一定已经完成资源创建或者修改，而只是被接受，可能还有服务器的后续的处理。

**204 No Content **

表明请求处理成功，但是作为服务器并不想要提供消息在消息主体内，或者并没有什么消息主体需要提供。 比如使用DELETE请求情况下，如果服务成功完成，可以返回204 No Content。此场景下就是告诉客户端：“你的DELETE请求已经完成，但是因为这个资源已经被删除，所以，也就没有什么需要返回的消息”。

204 对用户代理（浏览器）也是有意义的。用户代理收到204，就不应该引发请求的文档的当前视图（就是不要去刷新当前文档，也不要导航到别的URL）。这就意味着，如果有一个 HTML Form然后提交，如果服务器返回的状态是204状态，那么浏览器不可以刷新窗口或者到其他的页面。所有的 Form 输入的内容都不要改变。当然这样的做法在用户代理中很少有人如此实践。因为用户点击发生了，和服务器的交互也发生了，而用户界面却对此毫无响应，那么这样的做法显然会让用户感到迷惑。

可要是在ajax的应用上下文，这样做就比较有价值了。ajax应用获得204状态返回就可以提示用户操作已经成功。并且如同204状态码的意图，不需修改当前 Form 的任何值。因为服务本来不需要返回任何具体数据，它只需要告诉客户端请求已经成功处理。

**205 Reset Content **

此状态码告诉客户端请求已经成功执行。不同于204，它的意图是要告诉客户应该清除Form的内容或者刷新用户界面。具体说，我可以填写Form，提交后，如果接到了205响应，就应该重设Form，然后初始化一个新的输入。

事实上，并没有什么浏览器支持这样的意图：浏览器要么把205当成204，要么当成200。然而，对于ajax应用就可以实现这样的意图：ajax应用接到205码，用户界面应该把数据设置到默认值。如果是 Restful App ，在数据输入场景下，204响应适合对一条记录做一系列的编辑；205更适合输入一系列的记录；故而，Restful App的建议更加尊重http的设计本意。

**206 Partical Content（部分内容） **

它的存在目的是为了支持大文件的分段下载。当客户端发起资源范围请求，服务器就可以返回206型响应，告知客户端操作成功并且返回部分内容。见如下案例：

```
HEAD /large.jpg HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Length: 3980

GET /large.jpg HTTP/1.1
Host: example.com
Range: bytes=0-999

HTTP/1.1 206 Partial Content
Accept-Ranges: bytes
Content-Length: 1000
Content-Range: bytes 0-999/3980

{binary data}

GET /large.jpg HTTP/1.1
Host: example.com
Range: bytes=1000-

HTTP/1.1 206 Partial Content
Accept-Ranges: bytes
Content-Length: 2980
Content-Range: bytes 1000-3979/3980

{binary data}
```

上面的案例中，首先通过HEAD 方法查询资源的大小、以及查询是否支持分段下载。服务器如果支持分段下载就通过Accept-Ranges: bytes 的首部字段指示它是支持的。接下来，客户端就可以通过首部字段 Range 来指定要获取资源的范围。而服务器通过206 Partial Content指示获取成功、本次获取为部分内容、和本次获取部分资源的范围。

### 300 型响应

3xx系列的响应涉及的状态码除了304 Not Modified 之外都是用于重定向的。我们首先查看3xx系列的重定向状态码和描述：

* 300 Multiple Choices 客户端请求了实际指向多个资源的URL。
* 301 Moved Permanently 请求的 URL 已移走。
* 302 Found 请求的URL临时移走
* 303 See Other 客户端应该使用指定URL
* 307 Temporary Redirect 客户端应该临时定位到指定URL

于是，看起来并不复杂的重定向，稍微对比就会感到很混淆的。特别是301/302 ，303/307 一组，好像根本就是重复的。我们会在下文解释。

**300 multiple choices **

含义在于——同样的一个URL，可以对应多个实际的资源。比如同样的软件下载可以有多个平台的版本，或者多种打包压缩格式。又比如，同样的文档可以有不同的文档格式 。客户端可以在这些结果中，根据自己的情况作出自动的选择（比如中文用户就自动选择中文文档），或者给出列表，提交给最终用户选择。

可是，标准内并没有给出具体的多个选择项的格式。因此，该状态码很少被标准的web服务器和用户代理使用。我看到的两本和http有关的书，讲到状态码 300 的时候，一本语焉不详，一本干脆略过，想来也是这样的原因。

但是程序员完全可以在300状态码的基本含义情况下，具体化多资源构造的格式，在自己的应用的客户端和服务器之间遵守，然后实现应用的特定目的。比如，在实体主体内自定义如下的格式：

```
HTTP/1.1 300 Multiple Choices
Date: Tue, 11 Jun 1996 20:02:21 GMT
Content-Type: text/html
Content-Length: 130

<h2>Multiple Choices:</h2>
<ul>
<li><a href=paper.1>HTML</a>
<li><a href=paper.2>Kindle</a>
<li><a href=paper.3>Doc</a>
</ul>
```

要么提供选择界面 ，由用户选择其中一个、要么由用户代理自动选择，然后重定向到这个资源去。

**301 Moved Permanently **

说的是客户端请求的 URL 对应的资源已经被挪到其他位置，这个新位置已经在响应消息的LOCATION 头字段内指定。如果你的书签使用了这个URL，那么应该由用户代理自动更新到新的位置。下次访问也希望使用新的URL。

客户端请求:

```
GET /abc HTTP/1.1
Host: www.example.org
```

服务器响应:

```
HTTP/1.1 301 Moved Permanently
Location: http://www.example.org/def
```

**302 Found **

说的是你当前访问的URL对应的资源暂时被移动到一个新位置，这个新位置在Location头内指定。和301不同的是，302并不影响你的书签，你也不必下次访问新的URL，因为这个变化是暂时的。实际上，这个状态码在HTTP 1.0引入，本来命名就是 302 Moved Temporarily，以便和301对照使用。

客户端请求：

```
GET /abc HTTP/1.1
Host: www.example.org
```

服务器响应：

```
HTTP/1.1 302 Found
Location: http://www.example.org/def
```

然而，对于这个状态码，标准本来希望的是保持两次请求的请求方法一致的。就是说，原来用POST重定向就用POST；原来用GET方法请求的，重定向后也继续用 GET 方法。而实际上，众多的用户代理都做了和标准不一致的实现：不管原来引发请求的是POST，还是GET，在重定向后都改成了GET方法。这是不恰当的实现，但是因为大家都这么实现，故而它反而成为了事实上的标准。为此，在修订 HTTP 1.1版本时就又引入了303 See Other 和307 Temporary Redirect 状态码，以便解决标准和实现不一致引发的语义问题。请继续阅读，以便理解这两个新的、看起来有些混淆的状态码。

**303 See Other **

此状态码也是重定向。但是它不管之前的请求方法是什么，都强制要求转换请求方法为GET

**307 Temporary Redirect **

此状态码也是重定向响应。但是它和303不同，它要保持新的请求方法和之前发起请求的请求方法一致。就是说，如果之前是 GET 方法，那么这次重定向也需继续使用GET 方法；之前使用POST方法，这次依然需要保持使用POST 方法。

**304 Not Modified **

此状态码其实和重定向无关。但是总不至于单独为它一个而增加一个分类，所以就放到了300系列内。当用户代理发起GET请求并设置了修改时间的前条件，而服务器发现被请求的资源并没有在给出的时间后被修改，就会返回这个状态码。这个状态码的存在是为了性能上的考量。不必传递用户代理有的、服务器也没有修改的资源。案例：

客户端请求：

```
GET /sample.html HTTP/1.1
Host: example.com
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
```

服务器响应：

```
HTTP/1.1 304 Not Modified
Date: Tue, 27 Dec 2005 05:25:19 GMT 
```

### 400 型响应











